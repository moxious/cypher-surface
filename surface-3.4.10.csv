"version","type","name","signature","description","mode"
"3.4.10","function","date","date(input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATE?)","Create a Date instant.",""
"3.4.10","function","date.realtime","date.realtime(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATE?)","Get the current Date instant using the realtime clock.",""
"3.4.10","function","date.statement","date.statement(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATE?)","Get the current Date instant using the statement clock.",""
"3.4.10","function","date.transaction","date.transaction(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATE?)","Get the current Date instant using the transaction clock.",""
"3.4.10","function","date.truncate","date.truncate(unit :: STRING?, input :: ANY?, fields = null :: MAP?) :: (DATE?)","Truncate the input temporal value to a Date instant using the specified unit.",""
"3.4.10","function","datetime","datetime(input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATETIME?)","Create a DateTime instant.",""
"3.4.10","function","datetime.fromepoch","datetime.fromepoch(seconds :: NUMBER?, nanoseconds :: NUMBER?) :: (DATETIME?)","Create a DateTime given the seconds and nanoseconds since the start of the epoch.",""
"3.4.10","function","datetime.fromepochmillis","datetime.fromepochmillis(milliseconds :: NUMBER?) :: (DATETIME?)","Create a DateTime given the milliseconds since the start of the epoch.",""
"3.4.10","function","datetime.realtime","datetime.realtime(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATETIME?)","Get the current DateTime instant using the realtime clock.",""
"3.4.10","function","datetime.statement","datetime.statement(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATETIME?)","Get the current DateTime instant using the statement clock.",""
"3.4.10","function","datetime.transaction","datetime.transaction(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (DATETIME?)","Get the current DateTime instant using the transaction clock.",""
"3.4.10","function","datetime.truncate","datetime.truncate(unit :: STRING?, input :: ANY?, fields = null :: MAP?) :: (DATETIME?)","Truncate the input temporal value to a DateTime instant using the specified unit.",""
"3.4.10","function","duration","duration(input :: ANY?) :: (DURATION?)","Construct a Duration value.",""
"3.4.10","function","duration.between","duration.between(from :: ANY?, to :: ANY?) :: (DURATION?)","Compute the duration between the 'from' instant (inclusive) and the 'to' instant (exclusive) in logical units.",""
"3.4.10","function","duration.inDays","duration.inDays(from :: ANY?, to :: ANY?) :: (DURATION?)","Compute the duration between the 'from' instant (inclusive) and the 'to' instant (exclusive) in days.",""
"3.4.10","function","duration.inMonths","duration.inMonths(from :: ANY?, to :: ANY?) :: (DURATION?)","Compute the duration between the 'from' instant (inclusive) and the 'to' instant (exclusive) in months.",""
"3.4.10","function","duration.inSeconds","duration.inSeconds(from :: ANY?, to :: ANY?) :: (DURATION?)","Compute the duration between the 'from' instant (inclusive) and the 'to' instant (exclusive) in seconds.",""
"3.4.10","function","localdatetime","localdatetime(input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALDATETIME?)","Create a LocalDateTime instant.",""
"3.4.10","function","localdatetime.realtime","localdatetime.realtime(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALDATETIME?)","Get the current LocalDateTime instant using the realtime clock.",""
"3.4.10","function","localdatetime.statement","localdatetime.statement(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALDATETIME?)","Get the current LocalDateTime instant using the statement clock.",""
"3.4.10","function","localdatetime.transaction","localdatetime.transaction(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALDATETIME?)","Get the current LocalDateTime instant using the transaction clock.",""
"3.4.10","function","localdatetime.truncate","localdatetime.truncate(unit :: STRING?, input :: ANY?, fields = null :: MAP?) :: (LOCALDATETIME?)","Truncate the input temporal value to a LocalDateTime instant using the specified unit.",""
"3.4.10","function","localtime","localtime(input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALTIME?)","Create a LocalTime instant.",""
"3.4.10","function","localtime.realtime","localtime.realtime(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALTIME?)","Get the current LocalTime instant using the realtime clock.",""
"3.4.10","function","localtime.statement","localtime.statement(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALTIME?)","Get the current LocalTime instant using the statement clock.",""
"3.4.10","function","localtime.transaction","localtime.transaction(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (LOCALTIME?)","Get the current LocalTime instant using the transaction clock.",""
"3.4.10","function","localtime.truncate","localtime.truncate(unit :: STRING?, input :: ANY?, fields = null :: MAP?) :: (LOCALTIME?)","Truncate the input temporal value to a LocalTime instant using the specified unit.",""
"3.4.10","function","randomUUID","randomUUID() :: (STRING?)","Generates a random UUID.",""
"3.4.10","function","time","time(input = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (TIME?)","Create a Time instant.",""
"3.4.10","function","time.realtime","time.realtime(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (TIME?)","Get the current Time instant using the realtime clock.",""
"3.4.10","function","time.statement","time.statement(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (TIME?)","Get the current Time instant using the statement clock.",""
"3.4.10","function","time.transaction","time.transaction(timezone = DEFAULT_TEMPORAL_ARGUMENT :: ANY?) :: (TIME?)","Get the current Time instant using the transaction clock.",""
"3.4.10","function","time.truncate","time.truncate(unit :: STRING?, input :: ANY?, fields = null :: MAP?) :: (TIME?)","Truncate the input temporal value to a Time instant using the specified unit.",""
"3.4.10","procedure","db.awaitIndex","db.awaitIndex(index :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID","Wait for an index to come online (for example: CALL db.awaitIndex(\":Person(name)\")).","READ"
"3.4.10","procedure","db.awaitIndexes","db.awaitIndexes(timeOutSeconds = 300 :: INTEGER?) :: VOID","Wait for all indexes to come online (for example: CALL db.awaitIndexes(\"500\")).","READ"
"3.4.10","procedure","db.constraints","db.constraints() :: (description :: STRING?)","List all constraints in the database.","READ"
"3.4.10","procedure","db.createIndex","db.createIndex(index :: STRING?, providerName :: STRING?) :: (index :: STRING?, providerName :: STRING?, status :: STRING?)","Create a schema index with specified index provider (for example: CALL db.createIndex(\":Person(name)\", \"lucene+native-2.0\")) - YIELD index, providerName, status","SCHEMA"
"3.4.10","procedure","db.createLabel","db.createLabel(newLabel :: STRING?) :: VOID","Create a label","WRITE"
"3.4.10","procedure","db.createProperty","db.createProperty(newProperty :: STRING?) :: VOID","Create a Property","WRITE"
"3.4.10","procedure","db.createRelationshipType","db.createRelationshipType(newRelationshipType :: STRING?) :: VOID","Create a RelationshipType","WRITE"
"3.4.10","procedure","db.createUniquePropertyConstraint","db.createUniquePropertyConstraint(index :: STRING?, providerName :: STRING?) :: (index :: STRING?, providerName :: STRING?, status :: STRING?)","Create a unique property constraint with index backed by specified index provider (for example: CALL db.createUniquePropertyConstraint(\":Person(name)\", \"lucene+native-2.0\")) - YIELD index, providerName, status","SCHEMA"
"3.4.10","procedure","db.index.explicit.addNode","db.index.explicit.addNode(indexName :: STRING?, node :: NODE?, key :: STRING?, value :: ANY?) :: (success :: BOOLEAN?)","Add a node to an explicit index based on a specified key and value","WRITE"
"3.4.10","procedure","db.index.explicit.addRelationship","db.index.explicit.addRelationship(indexName :: STRING?, relationship :: RELATIONSHIP?, key :: STRING?, value :: ANY?) :: (success :: BOOLEAN?)","Add a relationship to an explicit index based on a specified key and value","WRITE"
"3.4.10","procedure","db.index.explicit.auto.searchNodes","db.index.explicit.auto.searchNodes(query :: ANY?) :: (node :: NODE?, weight :: FLOAT?)","Search nodes in explicit automatic index. Replaces `START n=node:node_auto_index('key:foo*')`","READ"
"3.4.10","procedure","db.index.explicit.auto.searchRelationships","db.index.explicit.auto.searchRelationships(query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit automatic index. Replaces `START r=relationship:relationship_auto_index('key:foo*')`","READ"
"3.4.10","procedure","db.index.explicit.auto.seekNodes","db.index.explicit.auto.seekNodes(key :: STRING?, value :: ANY?) :: (node :: NODE?)","Get node from explicit automatic index. Replaces `START n=node:node_auto_index(key = 'A')`","READ"
"3.4.10","procedure","db.index.explicit.auto.seekRelationships","db.index.explicit.auto.seekRelationships(key :: STRING?, value :: ANY?) :: (relationship :: RELATIONSHIP?)","Get relationship from explicit automatic index. Replaces `START r=relationship:relationship_auto_index(key = 'A')`","READ"
"3.4.10","procedure","db.index.explicit.drop","db.index.explicit.drop(indexName :: STRING?) :: (type :: STRING?, name :: STRING?, config :: MAP?)","Remove an explicit index - YIELD type,name,config","WRITE"
"3.4.10","procedure","db.index.explicit.existsForNodes","db.index.explicit.existsForNodes(indexName :: STRING?) :: (success :: BOOLEAN?)","Check if a node explicit index exists","READ"
"3.4.10","procedure","db.index.explicit.existsForRelationships","db.index.explicit.existsForRelationships(indexName :: STRING?) :: (success :: BOOLEAN?)","Check if a relationship explicit index exists","DEFAULT"
"3.4.10","procedure","db.index.explicit.forNodes","db.index.explicit.forNodes(indexName :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)","Get or create a node explicit index - YIELD type,name,config","WRITE"
"3.4.10","procedure","db.index.explicit.forRelationships","db.index.explicit.forRelationships(indexName :: STRING?, config = {} :: MAP?) :: (type :: STRING?, name :: STRING?, config :: MAP?)","Get or create a relationship explicit index - YIELD type,name,config","WRITE"
"3.4.10","procedure","db.index.explicit.list","db.index.explicit.list() :: (type :: STRING?, name :: STRING?, config :: MAP?)","List all explicit indexes - YIELD type,name,config","READ"
"3.4.10","procedure","db.index.explicit.removeNode","db.index.explicit.removeNode(indexName :: STRING?, node :: NODE?, key =  <[9895b15e-8693-4a21-a58b-4b7b87e09b8e]>  :: STRING?) :: (success :: BOOLEAN?)","Remove a node from an explicit index with an optional key","WRITE"
"3.4.10","procedure","db.index.explicit.removeRelationship","db.index.explicit.removeRelationship(indexName :: STRING?, relationship :: RELATIONSHIP?, key =  <[9895b15e-8693-4a21-a58b-4b7b87e09b8e]>  :: STRING?) :: (success :: BOOLEAN?)","Remove a relationship from an explicit index with an optional key","WRITE"
"3.4.10","procedure","db.index.explicit.searchNodes","db.index.explicit.searchNodes(indexName :: STRING?, query :: ANY?) :: (node :: NODE?, weight :: FLOAT?)","Search nodes in explicit index. Replaces `START n=node:nodes('key:foo*')`","READ"
"3.4.10","procedure","db.index.explicit.searchRelationships","db.index.explicit.searchRelationships(indexName :: STRING?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit index. Replaces `START r=relationship:relIndex('key:foo*')`","READ"
"3.4.10","procedure","db.index.explicit.searchRelationshipsBetween","db.index.explicit.searchRelationshipsBetween(indexName :: STRING?, in :: NODE?, out :: NODE?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit index, starting at the node 'in' and ending at 'out'.","READ"
"3.4.10","procedure","db.index.explicit.searchRelationshipsIn","db.index.explicit.searchRelationshipsIn(indexName :: STRING?, in :: NODE?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit index, starting at the node 'in'.","READ"
"3.4.10","procedure","db.index.explicit.searchRelationshipsOut","db.index.explicit.searchRelationshipsOut(indexName :: STRING?, out :: NODE?, query :: ANY?) :: (relationship :: RELATIONSHIP?, weight :: FLOAT?)","Search relationship in explicit index, ending at the node 'out'.","READ"
"3.4.10","procedure","db.index.explicit.seekNodes","db.index.explicit.seekNodes(indexName :: STRING?, key :: STRING?, value :: ANY?) :: (node :: NODE?)","Get node from explicit index. Replaces `START n=node:nodes(key = 'A')`","READ"
"3.4.10","procedure","db.index.explicit.seekRelationships","db.index.explicit.seekRelationships(indexName :: STRING?, key :: STRING?, value :: ANY?) :: (relationship :: RELATIONSHIP?)","Get relationship from explicit index. Replaces `START r=relationship:relIndex(key = 'A')`","READ"
"3.4.10","procedure","db.indexes","db.indexes() :: (description :: STRING?, label :: STRING?, properties :: LIST? OF STRING?, state :: STRING?, type :: STRING?, provider :: MAP?, failureMessage :: STRING?)","List all indexes in the database.","READ"
"3.4.10","procedure","db.labels","db.labels() :: (label :: STRING?)","List all labels in the database.","READ"
"3.4.10","procedure","db.propertyKeys","db.propertyKeys() :: (propertyKey :: STRING?)","List all property keys in the database.","READ"
"3.4.10","procedure","db.relationshipTypes","db.relationshipTypes() :: (relationshipType :: STRING?)","List all relationship types in the database.","READ"
"3.4.10","procedure","db.resampleIndex","db.resampleIndex(index :: STRING?) :: VOID","Schedule resampling of an index (for example: CALL db.resampleIndex(\":Person(name)\")).","READ"
"3.4.10","procedure","db.resampleOutdatedIndexes","db.resampleOutdatedIndexes() :: VOID","Schedule resampling of all outdated indexes.","READ"
"3.4.10","procedure","db.schema","db.schema() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)","Show the schema of the data.","READ"
"3.4.10","procedure","db.schema.nodeTypeProperties","db.schema.nodeTypeProperties() :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)","Show the derived property schema of the nodes in tabular form.","READ"
"3.4.10","procedure","db.schema.relTypeProperties","db.schema.relTypeProperties() :: (relType :: STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)","Show the derived property schema of the relationships in tabular form.","READ"
"3.4.10","procedure","dbms.changePassword","dbms.changePassword(password :: STRING?) :: VOID","Change the current user's password. Deprecated by dbms.security.changePassword.","DBMS"
"3.4.10","procedure","dbms.clearQueryCaches","dbms.clearQueryCaches() :: (value :: STRING?)","Clears all query caches.","DBMS"
"3.4.10","procedure","dbms.components","dbms.components() :: (name :: STRING?, versions :: LIST? OF STRING?, edition :: STRING?)","List DBMS components and their versions.","READ"
"3.4.10","procedure","dbms.functions","dbms.functions() :: (name :: STRING?, signature :: STRING?, description :: STRING?)","List all user functions in the DBMS.","DBMS"
"3.4.10","procedure","dbms.listConfig","dbms.listConfig(searchString =  :: STRING?) :: (name :: STRING?, description :: STRING?, value :: STRING?)","List the currently active config of Neo4j.","DBMS"
"3.4.10","procedure","dbms.procedures","dbms.procedures() :: (name :: STRING?, signature :: STRING?, description :: STRING?, mode :: STRING?)","List all procedures in the DBMS.","DBMS"
"3.4.10","procedure","dbms.queryJmx","dbms.queryJmx(query :: STRING?) :: (name :: STRING?, description :: STRING?, attributes :: MAP?)","Query JMX management data by domain and name. For instance, \"org.neo4j:*\"","READ"
"3.4.10","procedure","dbms.security.changePassword","dbms.security.changePassword(password :: STRING?) :: VOID","Change the current user's password.","DBMS"
"3.4.10","procedure","dbms.security.createUser","dbms.security.createUser(username :: STRING?, password :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID","Create a new user.","DBMS"
"3.4.10","procedure","dbms.security.deleteUser","dbms.security.deleteUser(username :: STRING?) :: VOID","Delete the specified user.","DBMS"
"3.4.10","procedure","dbms.security.listUsers","dbms.security.listUsers() :: (username :: STRING?, flags :: LIST? OF STRING?)","List all local users.","DBMS"
"3.4.10","procedure","dbms.security.showCurrentUser","dbms.security.showCurrentUser() :: (username :: STRING?, flags :: LIST? OF STRING?)","Show the current user. Deprecated by dbms.showCurrentUser.","DBMS"
"3.4.10","procedure","dbms.showCurrentUser","dbms.showCurrentUser() :: (username :: STRING?, flags :: LIST? OF STRING?)","Show the current user.","DBMS"
